# ═══════════════════════════════════════════════════════════════
# Playwright Test Scaffold - Cursor Rules
# ═══════════════════════════════════════════════════════════════
# AI 驱动的自动化测试脚手架 - Cursor 对话时自动参考

## 项目定位

这是一个 **AI 驱动的 Playwright + Python 自动化测试脚手架**，通过自然语言对话生成：
- Page Object 页面对象
- Test Cases 测试用例
- Test Data 测试数据
- Allure Reports 测试报告

**使用方式：只通过 AI 对话交互，无需命令行。**

## ⚠️ 代码生成前必读（Critical）

**在生成任何 Page Object 或 Test Case 代码之前，必须先读取以下文件：**

```
必读文件（按顺序）：
1. generators/test_plan_generator.py  → 测试计划模板
2. generators/test_code_generator.py  → 代码模板（怎么写）
3. utils/logger.py                    → Logger 使用方式
```

### 关键实现细节

```python
# ❌ 错误：在模块级别创建 logger
from utils.logger import TestLogger
logger = TestLogger("test_xxx")  # 所有测试共享同一个名称

# ✅ 正确：在每个测试方法内部创建 logger，使用测试方法名
from utils.logger import TestLogger

def test_p0_page_load(self):
    logger = TestLogger("test_p0_page_load")  # 每个方法用自己的名称
    logger.start()
    logger.checkpoint("xxx", True)
    logger.end(success=True)

# ✅ @allure.title() 只显示测试方法名，不加 TC-XX-XXX
@allure.title("test_p0_page_load")  # ✅ 简洁
@allure.title("TC-CP-001: xxx")     # ❌ 冗余
```

### 检查清单

生成代码前确认：
- [ ] 已读取 `generators/test_code_generator.py`
- [ ] 已读取 `utils/logger.py` 了解 `TestLogger` 用法
- [ ] 已查看 `pages/` 目录现有 Page Object 风格
- [ ] 测试方法命名使用 `test_p{0,1,2}_xxx` 格式
- [ ] **TestLogger 在每个测试方法内部创建，使用测试方法名**
- [ ] **@allure.title() 只写测试方法名（如 `test_p0_page_load`）**
- [ ] 测试方法包含 `logger.start()` / `logger.checkpoint()` / `logger.end()`

## 核心架构

```
playwright-test-scaffold/
├── core/           # 核心框架
│   ├── base_page.py      # 页面对象基类
│   ├── page_utils.py     # 页面工具类
│   └── fixtures.py       # pytest fixtures
├── generators/     # 代码生成器
│   ├── page_analyzer.py      # 页面分析器
│   └── test_code_generator.py # 测试代码生成
├── pages/          # Page Objects
├── tests/          # Test Cases
├── test-data/      # 测试数据
└── config/         # 配置文件
```

## AI 对话指令处理

当用户说以下类型的指令时，按照规范生成代码：

### 生成测试
```
"帮我生成 xxx 页面的测试"
"测试 https://xxx.com/page 页面"
"为 xxx 功能创建测试用例"
```
→ 生成 Page Object + Test Cases，包含完整的 Allure 集成

### 运行测试
```
"运行测试"
"执行测试，使用 4 个 worker"
"只运行 P0 测试"
"用 headed 模式运行"
```
→ 构建 pytest 命令并执行

### 查看报告
```
"打开 Allure 报告"
"查看测试报告"
```
→ 执行 allure serve allure-results

### 修复问题
```
"测试失败了，帮我修复"
"这个错误怎么解决"
```
→ 分析错误原因，修复代码

## 生成规范

### 1. Page Object 规范

```python
from core.base_page import BasePage
from utils.logger import get_logger

logger = get_logger(__name__)


class XxxPage(BasePage):
    """页面对象类"""
    
    # ═══════════════════════════════════════════════════════════════
    # SELECTORS
    # ═══════════════════════════════════════════════════════════════
    
    ELEMENT_NAME = "selector"  # 元素描述
    
    URL = "/path"
    page_loaded_indicator = "selector"
    
    # ═══════════════════════════════════════════════════════════════
    # NAVIGATION
    # ═══════════════════════════════════════════════════════════════
    
    def navigate(self) -> None:
        """导航到页面"""
        logger.info(f"导航到 Xxx 页面")
        self.goto(self.URL)
        self.wait_for_page_load()
    
    def is_loaded(self) -> bool:
        """检查页面是否加载完成"""
        return self.is_visible(self.page_loaded_indicator, timeout=5000)
    
    # ═══════════════════════════════════════════════════════════════
    # ACTIONS
    # ═══════════════════════════════════════════════════════════════
    
    def fill_xxx(self, value: str) -> None:
        """填写 xxx 字段"""
        logger.info(f"填写 xxx: {value}")
        self.fill(self.XXX_INPUT, value)
```

### 2. Test Case 规范

```python
import pytest
import allure
from pages.xxx_page import XxxPage
from utils.logger import TestLogger


def attach_expected(expectations: list[str]) -> None:
    """附加预期目标到 Allure 报告"""
    content = "\n".join(f"✓ {exp}" for exp in expectations)
    allure.attach(content, name="预期目标", attachment_type=allure.attachment_type.TEXT)


@allure.feature("功能模块")
class TestXxx:
    """测试类"""
    
    @pytest.fixture(autouse=True)
    def setup(self, page):
        self.page = page
        self.xxx_page = XxxPage(page)
    
    @pytest.mark.P0
    @pytest.mark.functional
    @allure.story("用户故事")
    @allure.title("test_p0_xxx")  # ⚠️ 只写测试方法名
    @allure.description("""
    **测试目的**: 验证什么功能
    
    **前置条件**:
    - 条件1
    
    **测试步骤**:
    1. 步骤描述
    """)
    def test_p0_xxx(self):
        """测试描述"""
        logger = TestLogger("test_p0_xxx")  # ⚠️ 每个方法内部创建
        logger.start()
        
        attach_expected(["预期结果1", "预期结果2"])
        
        with allure.step("Step 1: 步骤描述"):
            self.xxx_page.take_screenshot("tc_xx_001_before")
            # 执行操作
            logger.checkpoint("检查点描述", True)
        
        with allure.step("Step N: 验证结果"):
            assert condition, "断言失败信息"
            self.xxx_page.take_screenshot("tc_xx_001_result")
        
        logger.end(success=True)
```

### 3. 测试优先级

| 标记 | 含义 | 场景 |
|------|------|------|
| P0 | 核心功能 | 主流程、关键路径 |
| P1 | 重要功能 | 输入验证、边界值 |
| P2 | 一般功能 | UI样式、可访问性 |

### 4. 测试类型标记

```python
@pytest.mark.functional   # 功能测试
@pytest.mark.validation   # 验证测试
@pytest.mark.exception    # 异常测试
@pytest.mark.ui           # UI测试
```

## 测试数据

测试账号位于 `test-data/test_account_pool.json`

```python
def test_xxx(self, test_account):
    """使用 test_account fixture 获取测试账号"""
    username = test_account["username"]
    password = test_account["password"]
```

## Allure 报告必备元素

生成测试代码时**必须**包含：

1. `@allure.feature()` - 功能模块
2. `@allure.story()` - 用户故事
3. `@allure.title()` - **只写测试方法名**
4. `@allure.description()` - 测试描述
5. `attach_expected()` - 预期目标
6. `with allure.step()` - 步骤追踪
7. `take_screenshot()` - 关键步骤截图

## 代码风格

- 中文注释，英文代码
- 使用 ASCII 风格分块注释
- 文件不超过 400 行
- 函数职责单一
